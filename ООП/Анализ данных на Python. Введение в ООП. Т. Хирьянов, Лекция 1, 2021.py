import os
from abc import ABC, abstractmethod

"""
Парадигма ООП

- Данные структурируются в виде объектов, каждый из которых имеет определенный тип,
то есть принадлежит к какому-либо классу.

- Классы - результат формализации решаемой задачи, выделения главных ее аспектов.

- Внутри объекта инкапсулируется логика работы с относящейся к нему информацией.

- Объекты в программе взаимодействуют друг с другом, обмениваются запросами и ответами.

- При этом объекты одного типа сходным образом отвечают на одни и те же запросы.

- Объекты могут организовываться в более сложные структуры, например,
влючать другие объекты или наследовать от одного или нескольких объектов.

SOLID - принципы

S - Single responsibility principle
    Для каждого класса должно быть определено единственное назначение.
O - Open-closed principle
    "Программные сущности ... должны быть открыты для расширения, но закрыты для модификации"
    Возможно менять внутренний механизм реализации, но нельзя менять пользовательский интерфейс,
    сохраняя принцип обратной совместимости. Все "новое" только добавляется, сохраняя все "старое".
L - Liskov substitition principle
    "Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения
    правильности выполнения программы"
    Т.е. объекты подкласса должны уметь все то же, что и объекты родительского класса.
I - Interface segregation principle
    "Множество интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс
    общего назначения". Т.е. швейцарский нож - "зло". На каждую задачу, должен быть специальный инструмент.
D - Dependency inversion principle
    "Зависимость на Абстракциях. Нет зависимости на что-то конкретное".

Понятие объекта и класса

Объектно-ориентированное программирование (ООП) - парадигма программирования,
в которой основными концепциями являются понятия объектов и классов.

Класс - тип, описывающий устройство объектов.
Объект - это экземпляр класса.
Функция getattr() позволяет обращаться к атрибутам класса
Функция setattr() позволяет менять или уствновить новые атрибуты класса
Функция delattr() позволяет удалить атрибут класса
"""


# Простейший пример класса:
class Cls:
    pass


# Создание экземпляра класса: имя_объекта = имя_класса()
obj = Cls()


# Еще пример класса:
class Rectangle:
    default_color = "green"  # статический атрибут

    def __init__(self, width, height):  # конструктор класса - инициализирующий метод
        self.width = width  # динамический атрибут
        self.height = height  # динамический атрибут


"""
Магические методы классов в Python
Некоторые примеры:
__new__(cls, [...) - метод, котоырй будет вызван при инициализации объекта
__init__(self, [...) - инициализатор класса
__del__ - деструктор объекта
__dict__ - посмотреть все атрибуты, которые существуют в классе

В некоторых случаях присваивание имен вида __myname__ допустимо, но как правило такие имена
означают нечто специально, встроенное в интерпретатор определеннным образом и нужно читать документацию
"""


class FileObject:
    """Обертка для файлового объекта, чтобы быть уверенным в том,
       что файл будет закрыт при удалении.
    """

    def __init__(self, filepath='~', filename='sample.txt'):
        # открыть файл filename в filepath в режиме чтения и записи
        self.file = open(os.path.join(filepath, filename), 'r+')  # в лекции было: open(join(filepath, filename), 'r+')

    def __del__(self):  # специальный метод для закрытия объекта, но не факт что объект будет сразу уничтожен
        self.file.close()
        del self.file


"""
Статические методы, классовые методы, экземплярные методы
"""


class ToyClass:
    def instancemethod(self):  # метод экземпляра класса
        return 'instance method called', self

    @classmethod  # обертка декоратором
    def classmethod(cls):  # классовый метод
        return 'class method called', cls

    @staticmethod  # обертка декоратором
    def staticmethod():  # статический метод
        return 'static method called'


"""
Абстрактные классы

Абстрактным называется класс, который содержит один и более абстрактных методов.
Абстрактным методом называется объявленный, но не реализованный метод.
У абстрактного класса не бывает экземпляров.
Для создания абстрактного класса потребуется импорт специальной библиотеки:
from abc import ABC, abstractmethod
"""


class ChessPiece(ABC):
    # общий метод, который будут использовать все наследники этого класса
    @staticmethod
    def draw():
        print("Drew a chess piece")

    # абстрактный метод, который будет необходимо переопределять для каждого подкласса
    @abstractmethod
    def passmove(self):
        pass


"""
Декомпозиция программы на модули. Менеджер контекста.

Функции модулей:
- Повторное использование кода: такой код может быть загружен много раз во многих местах.

- Управление адресным пространством: модуль - это высокоуровневая организация программ, это пакет имен,
  который избавляет вас от конфликтов. Каждый объект "проживает" свой цикл внутри своего модуля,
  поэтому модуль - это средство для группировки системных компонентов.
  
- Глобализация сервисов и данных: для реализации объекта, который используется во многих местах,
  достаточно написать один модуль, который будет импортирован.
  
1. Модуль с именем my_module можно импортировать как import my_module или import my_module as mymo.
   После этого мы получаем доступ ко всем функциям определенным в модуле:
   mymo.func1()
   mymo.func2()
   f1 = mymo.func1
   
2. from my_module import func1, func2
   func1()
   
3. from my_module import *  # вывалить все, но лучше так не делать
   func1()
   
Стандартные модули:
- sys
- os
- tempfile
- fileinput
- csv
- datetime
- re
- turtle
и многие другие. Можно ознакомится тут https://docs.python.org

Модуль sys
exit([c]) - выход из программы. Можно передать числовой код завершения.
argv - список аргументов командной строки.
sys.argv[0] - содержит имя запущенной программы, а остальные параметры передаются из командной строки.
platform - платформа, на которой работает интерпретатор.
stdin, stdout, stderr - стандартный ввод, вывод, вывод ошибок.
version - версия интерпретатора.
setrecursionlimit(limit) - установка уровня максимальной вложенности рекурсивных вызовов.
exc_info() - Информация об обрабатываемом исключении.

Модуль os
os.curdir - текущий каталог
os.pardir - родительский каталог
os.sep - разделитель элементов пути
os.altsep - другой разделитель элементов пути
os.pathsep - разделитель путей в списке путей
os.defpath - список путей по умолчанию
os.linesep - признак окончания строки

Модуль tempfile
В некоторых случаях необходимо создать временный файл, который после выполнения некоторых действий уже не нужен.
Для этих целей можно использовать функцию TemporaryFile, которая возвращает файловый объект, готовый к записи и чтению.

Модуль csv
csv.reader
csv.writer
класс csv.Dictwriter - аналогичен классу DictWriter и выполняет противоположную функцию: запись данных в файл CSV.
класс csv.DictReader - создает объект, который отображает прочитанную информацию в словарь, ключи которого задаются
параметром fieldnames.

Обработка исключений
Системные исключения и ошибки:
SystemExit
KeyboardInterrupt
GeneratorExit

Обыкновенные исключения:
try:
    исполняем какой-то код
except Exception as e:
    обработка исключения
else:
    код, который будет исполнен в случае, когда не возникает исключения
finally:
    код, который гарантированно будет исполнен последним (всегда исполняется)

"""
