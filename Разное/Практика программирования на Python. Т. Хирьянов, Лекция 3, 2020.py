"""
Функции. Локальность имен.
Принцип "DRY":
Don't
Repeat
Yourself

Принцип "WET":
We
Enjoy
Typing

Бывает синхронный и асинхронный вызовы функций.

Стек вызовов - стек адресов возврата функций.
Каждый вызов функции порождает новое пространство имен, когда функция возвращает значение, ее пространство имен умирает
Локальное имя является приоритетным.
Приорететы использования пространств имен:
L - local
E - enclosed
G - global
B - built-in

Если имени нет ни в одном пространстве имен, то будет ошибка поиска имени.

Функция
"""


# простейшая функция
def foo() -> None:  # заголовок функции c аннотацией типа возвращаемого значения
    pass  # тело функции, после pass автоматически происходит return


x = foo()
print(type(x))  # объект <class 'NoneType'>


def foo_1(x: int, y: int) -> int:  # x и y это формальные параметры
    return x ** 2 + y


y = foo_1(3, 4)  # 3 и 4 - фактические параметры

"""
Duck typing - утиная типизация
Python программисты говорят "если это похоже на утку и крякает как утка, то это утка".
Не нужно проверять ДНК утки, чтобы понять утка ли это, нужно просто посмотреть на ее поведение.
Утиная типизация "DuckTyping" настолько глубоко заложена и распространена в Python,
что она действительно повсюду, как вода для рыбы: мы даже не думаем об этом.
В Python очень часто проще предположить поведение объектов, вместо проверки их типов.
"""


def foo_2(x: str, y: int) -> str:
    result = x
    for i in range(y):
        result += x
    return result


z = foo_2(2, 5)  # 12
print(z)
z = foo_2('Kva', 2)  # KvaKvaKva
print(z)


def foo_3(x, y, z=0):  # z - имеет значение по умолчанию
    return 100 * x + 10 * y + 1 * z


t = foo_3(1, 2, 3)
print(t)
print(foo_3(z=1, x=2, y=3))  # можно нарушить порядок параметров при явном указании - Именованные параметры
print(foo_3(4, 3))  # так можно вызвать функцию с двумя параметрами, если z имеет значение по умолчанию


def bar(args):  # функция ждет 1 аргумент, итерируемый объект
    for arg in args:
        print('bar arg =', arg)


bar([1, 2, 3])


def bar_1(*args):  # функция ждет произвольное количество аргументов
    for arg in args:
        print('bar arg =', arg)


bar_1(['jelly', 'fish'])
bar_1('jelly', 'fish')


def bar_1(*args, named_parameter="bar"):  # можем добавить дополнительный именованный параметр
    for arg in args:
        print(named_parameter, 'arg =', arg)


bar_1('jelly', 'fish', named_parameter="separator")  # пример вызова функции с указанием именованного параметра
