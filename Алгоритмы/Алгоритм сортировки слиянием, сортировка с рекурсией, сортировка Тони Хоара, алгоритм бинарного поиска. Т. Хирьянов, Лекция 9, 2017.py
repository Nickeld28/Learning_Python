"""
Алгоритм сортировки слиянием
Слияние отсортированных массивов

Сортировка называется устройчивой, если она не меняет порядок равных элементов
"""
def merge(A:list, B:list):
    """Функция слияния отсортированных массивов в один отсортированный,
    получает два отсортированных списка A и B, а возвращает список C"""

    C = [0] * (len(A) + len(B))
    i = 0  # индекс элемента в А
    k = 0  # индекс элемента в B
    n = 0  # индекс элемента в C
    while i < len(A) and k < len(B):
        if A[i] <= B[k]:  # для соблюдения устойчивой сортировки, иначе A[i] < B[k]
            C[n] = A[i]
            i += 1
            n += 1
        else:
            C[n] = B[k]
            k += 1
            n += 1
    while i < len(A):
        C[n] = A[i]
        i += 1
        n += 1
    while k < len(B):
        C[n] = B[k]
        k += 1
        n += 1
    return C

"""
Рекурсивная функция
Алгоритм рекурентной сортировки слиянием
"""

def merge_sort(A):
    """принимает несортированные элементы из массива А и возвращает их в отсортированном виде обратно в массив А,
    путем деления массива на две половинки, каждая половинка делится еще на две половинки, пока не дойдет до
    крайнего случая рекурсии. Получив две крохотных половинки минимального размера, они уже отсортированы сами в себе
     и функция merge начнет эти половинки объединять снова и снова вместе, так получится полностью отсортированный
     массив C. А далее мы не можем просто сказать A = C"""

    if len(A) <= 1:  # крайний случай рекурсии
        return
    middle = len(A) // 2  # середина
    L = [A[i] for i in range(0, middle)]  # левая половина
    R = [A[i] for i in range(middle, len(A))]  # правая половина
    merge_sort(L)
    merge_sort(R)
    C = merge(L, R)
    for i in range(len(A)):
        A[i] = C[i]

"""
Алгоритм сортировки Тони Хоара (QuickSort)

"""
def hoar_sort(A):
    """Возмем в качестве барьерного элемента А[0]. Затем каждый элемент массива мы будем сравнивать
    с барьерным элементом. Если сравниваемый элемент меньше барьерного, то мы его добавляем в массив L,
    если равен - то в массив M, а если больше - то в массив R. Затем L и R рекурентно сортируем
    и заново заполняем массив А отсортированными элементами из L, М, R"""

    L, M, R = [], [], []
    if len(A) <= 1:  # крайний случай
        return
    barrier = A[0]
    for x in A:
        if x < barrier:
            L.append(x)
        elif x == barrier:
            M.append(x)
        else:
            R.append(x)
    hoar_sort(L)
    hoar_sort(R)
    k = 0  # индекс массива А, который будем заново заполнять отсортированными элементами из L, M, R
    for x in L + M + R:
        A[k] = x
        k += 1


def check_sorted(A, ascending=True): # для сортировки по убвыванию пишем параметр False
    """Проверка отсортированности массива за O(len(A)) операций (за 1 проход)"""

    flag = True
    n = len(A)
    s = 2 * int(ascending) - 1  # int(True) = 1; int(False) = 0. И так s будет либо 1, либо -1
    for i in range(0, n - 1):
        if s * A[i] > s * A[i + 1]:  # В зависимости от True или False s будет менять это условие в обратную сторону
            flag = False
            break
    return flag

"""
Бинарный поиск
Алгоритм бинарного поиска в массиве
Требование: массив должен быть отсортирован в известном направлении (по возрастанию или убыванию)
Скорость поиска очень высока, О(lg2_N)
"""

def left_bound(A, key):  # A - отсортированный массив, key - искомый элемент
    left = -1  # изначальная позиция левой границы
    right = len(A)  # изначальная позиция правой границы
    while right - left > 1:
        middle = (left + right) // 2  # находим середину между левой и правой границей
        if A[middle] < key:
            left = middle
        else:
            right = middle
    return left


def right_bound(A, key):  # A - отсортированный массив, key - искомый элемент
    left = -1  # изначальная позиция левой границы
    right = len(A)  # изначальная позиция правой границы
    while right - left > 1:
        middle = (left + right) // 2  # находим середину между левой и правой границей
        if A[middle] <= key:
            left = middle
        else:
            right = middle
    return right

""" Тестирование """
if __name__ == "__main__":
    A = [3, 5, 7, 34, 4, 67, 4, 23, 5, 7, 4, 33, 4, 5, 4, 56]  # Возьмем для примера несортированный массив
    hoar_sort(A)  # Отсортируем алгоритмом Тони Хоара
    print(check_sorted(A))  # Проверка сортировки массива, возвращает True
    key = 9238  # Пробуем искать элементы в массиве
    if right_bound(A, key) - left_bound(A, key) > 1:
        print('Элемент', key, 'присутствует в массиве')
    else:
        print('Элемент', key, 'отсутствует в массиве')
