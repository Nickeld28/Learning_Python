"""
Давайте поиграем с клеточными автоматами.

В начале у вас есть список из элементов, которые могут принимать значения: '#' ("живой") или '.' ("мертвый").
Потом состояния элементов обновляются по следующим правилам:

Если у "живого" элемента два "живых" или нет ни одного "живого" соседа, то он "умирает".
Если у "мертвого" элемента есть хотя бы один "живой" сосед, то он "оживает".
В остальных случаях элементы не меняют своего состояния.
Прочитайте строку из символов "#" и ".", выведите список, который соответвует состоянию системы на k-ом шаге.

Смотрите примеры.

Sample Input 1:
#####
1

Sample Output 1:
['#', '.', '.', '.', '#']

Sample Input 2:
.#.
1

Sample Output 2:
['#', '.', '#']

Sample Input 3:
...
1

Sample Output 3:
['.', '.', '.']

Sample Input 4:
.##..#..#.#.
1

Sample Output 4:
['#', '#', '#', '#', '#', '.', '#', '#', '.', '#', '.', '#']

Sample Input 5:
#....#
4
Sample Output 5:
['#', '#', '.', '.', '#', '#']
"""

lst = ['.'] + list(input()) + ['.']
for k in range(int(input())):
    lst_tmp = lst.copy()
    for i in range(1, len(lst_tmp) - 1):
        if lst_tmp[i] == '#' and lst_tmp[i - 1] == lst_tmp[i + 1]:
            lst[i] = '.'
        elif lst_tmp[i - 1] == '#' or lst_tmp[i + 1] == '#':
            lst[i] = '#'
print(lst[1:-1])
