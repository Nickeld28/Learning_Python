import turtle as t
from functools import reduce

"""
Функциональное программирование

"Царства" в языках программирвоания (ЯП):
1. Императивные (строго определена последовательность действий (команд, инструкций)) Чисто императивный ЯП: Assembler
2. Функциональные (в чисто функциональных ЯП нет переменных и присваивания, а есть функции и константы) ЯП: Haskell, Elm
3. Логические (ЯП Prolog) (нас это не будет интересовать)

Процедурное программирование — программирование на императивном языке,
при котором последовательно выполняемые операторы можно собрать в подпрограммы,
то есть более крупные целостные единицы кода, с помощью механизмов самого языка.

Функциональное программирование — парадигма программирования, в которой процесс вычисления трактуется
как вычисление значений функций в математическом понимании последних
(в отличие от функций как подпрограмм в процедурном программировании).

Функциолальные ЯП бывают "чисто функциольные" (purely functional languages), использующие только функции
и бывают не "чисто функциольные".

Математически доказано, что любой итерационный процесс может быть заменен на рекурсивный и наоборот.
Т.е. можно использовать рекурсию вместо циклов и циклы вместо рекурсии.
В функциональном программировании нет циклов.

Попробуем "пожить" в функциональном программировании:
Сделаем функцию, с помощью которой можно распечать числа в прогрессии без использования циклов,
лишь с помощью рекурсии.
"""


def progression(start, stop, step):
    if start >= stop:
        return
    else:
        print(start)
        progression(start + step, stop, step)


progression(0, 10, 1)


# фрактальная фигура "Снежинка Коха"
def go_snowy(length):
    if length < 10:
        t.forward(length)
    else:
        go_snowy(length / 3)
        t.left(60)
        go_snowy(length / 3)
        t.right(120)
        go_snowy(length / 3)
        t.left(60)
        go_snowy(length / 3)


# фрактальная фигура "Снежинка Коха"
t.penup()
t.goto(-500, 200)
t.pendown()
t.speed(10)
go_snowy(30)
t.right(120)
go_snowy(30)
t.right(120)
go_snowy(30)
t.done()

"""
Итерируемые объекты (последовательности)

Функция получает число и возвращает число, или получает 3 числа и возращает два числа.
Общий вид:  x --> f(x) --> y
"""


def f(a, b, c):
    return a + b, b + c


x, y = f(1, 2, 3)
print(x)  # 3
print(y)  # 5

"""
Функция может получать одно число, а возвращает множество чисел
Общий вид: x -- > f(x) --> y_0, y_1, y_2, y_3, y_4, y_5 ... y_n
Т.е. может быть бесконечный поток значений (последовательность).

Функция может принимать последовательность значений, а возвращать одно число
Общий вид: x_0, x_1, x_2, ... x_n  -- > f(x) --> y
Т.е. мы имеем дело с последовательностью аргументов, и эта последовательность является особым типом объектов,
и их можно обрабатывать поэлементно.
Редуктор - тип функций которые занимаются редукцированием, понижают размерность.

И другой вид функций принимает последовательность значений и возвращает последовательность значений
Общий вид: x_0, x_1, x_2, ... x_n  -- > f(x_0), f(x_1), f(x_2), ... f(x_n)
По сути функция f(x), примененная многократно.

Итерируемый объект, это объект который можно перебирать поэлементно.

В Python есть как минимум два способа перебрать итерируемый объект.

Первый споcоб - использование генераторов. Цикл for в этом случае не противоречит функциональной парадигме.
"""


def f1(v):
    print(f"calculating {v} * 10")
    return v * 10


series_1 = (1, 2, 3, 4)
series_2 = (f1(x) for x in series_1)
print(type(series_2))

for y in series_2:
    print(y)

"""
Второй способ - использование функции map, когда мы можем дать функцию в качества параметра. 
Но сначала сделаем свою функцию, которая принимает функцию в качестве аргумента
"""


def double_performer(func, x1):
    return func(func(x1))


def f2(x2): return x2 * x2


def f3(x3): return -x3


print(double_performer(f1, 5))
f1(3)

for foo in f1, f2, f3:
    print(double_performer(foo, 5))

sample = map(f1, series_1)
print(type(sample))
for y in sample:
    print(y)

# в качестве итерируемого объекта можно пользоваться range
arr = range(10)
print(arr)
print(type(arr))  # range это не список, а генератор арифметических прогрессий
result = (el for el in arr if el % 2 == 0)  # создан объект для будущих вычислений, но не вычислены значения
print(result)  # показывает что есть объект в памяти
print(*result)  # вычислит все значения
print(*(el * el for el in arr if el % 2 == 1))  # можно записать так, но если сохраняется читаемость кода
# print(*map(el * el, arr))  - вот так делать нельзя, нужно обязательно описать функцию
print(*map(lambda el: el * el, arr))  # для этого можно использовать лямбда функции, "just in place"

series_1 = (1, 2, 3, 4, 5)
series_2 = tuple(el * 10 for el in series_1)
series_3 = zip(series_1, series_2)  # получился итерируемый объект zip, но он одноразовый
print(type(series_3))
for i in series_3:  # мы можем перебирать элементы зипа в цикле
    print(type(i))
    print(i, 'for loop')

it = iter(series_3)  # можно перебирать итерируемый объект вручную
# print(next(it))  # взять следующий элемент, но в данном случае он уже пустой, т.к. ранее циклом мы все перебрали
series_3 = zip(series_1, series_2)  # создадим снова зип объект
iter_ = iter(series_3)  # можно перебирать итерируемый объект вручную
print(next(iter_), 'iter')
print(next(iter_), 'iter')
print(next(iter_), 'iter')
print(next(iter_), 'iter')
print(next(iter_), 'iter')

for p1, p2 in zip(series_1, series_2):  # можно даже разобрать кортеж на элементы и делать операции с ними
    print(p1, p2, p1 + p2)

enumerate('HELLO')  # можно создать итерируемый объект функцией enumerate

for e, char in enumerate('HELLO'):
    print(e, char)

print(*map(lambda e_: e_[0] * e_[1], enumerate('HELLO')))


def arithm_progression(start, stop, step):
    var = start
    while var < stop:
        print(f'now working on var = {var}')
        yield var  # значение будет выдано, но действие функци не закончится, и такая функция уже не функция
        var += step


# так создается то, что называется сопрограммой
print(type(arithm_progression))
print(arithm_progression(1, 10, 2))
ar_pr = arithm_progression(1, 10, 2)
print(type(ar_pr))  # увидим что это генератор
for ar_el in ar_pr:  # вот так мы можем им воспользоваться
    print(ar_el)

series_1 = (1, 2, 3, 4, 5)
print(reduce(lambda o, p: o * p, series_1))  # произведение всех элементов в series_1
