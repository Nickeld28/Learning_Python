"""
Модули и пакеты

Проблема, которую решает модульное программирование - уменьшение сложности программы
за счет структурирования пространств имен (переменных, функций, объектов, классов)

Разбиение программы на модули можно сделать уже после напиания программы в процессе рефакторинга.
Когда это начинать делать:
1) Когда уже очень надо - рефакторинг
2) Либо можно сделать разбиение на модули заблаговременно - структурное программирование

Модуль может быть сложной структурой и объединять в себе несколько модулей, такой особый модуль называется пакетом.

Главный модель программы называют main.
Структурирование должно быть оправдано сложностью задачи.

Чем отличается фреймворк от пакета модулей?
Отдельные пакеты могут решать отдельные задачи, а фреймворк представляет собой целый набор функционала, которого
достаточно, чтобы решать все те задачи, для которых он предназначен. Внутри фреймворка компоненты тесно взаимосвязаны
друг с другом, а в отдельных пакетах модулей - нет.

Ипморт пакетов

Import module # предпочтительный способ импорта модуля
foo = 5
module.foo(1, 2, 3)  # не возникает конфликтов пространств имен, функция может быть с одним названием

from module import foo  # импорт конкретной функции из модуля
foo = 5  # создается конфликт имен и один объект заменит другой

from module import *  # очень плохой способ "вывалить" все содержимое модуля, будет множество невидимых конфликтов имен

from module_2 import *  # еще хуже вариант если импортировать дополнительные модули, конфликтов будет больше

import matplotlib.pyplot as p  # более предпочтительный способ укороченного вызова

import numpy as np  # часто используемый прием безопасного вызова

Пакет это папка с модулями, в котором лежит файл __init__.py

"""


def main():  # допустим в главном модуле есть функция main, которая отвечает за основной процесс выполнения программы
    pass


# мы можем прописать вот такое условие, чтобы вызов функции был доступен только непосредственно из файла самого
# модуля main, а при импорте этого модуля в другие модули не было автоматического вызова функции:

if __name__ == "__main__":
    main()

"""
Объектно-ориентированное программирование

Объекты и классы

Объект это переменная классового типа
Значение переменной соотносится с типом, а объект является значение классового типа.
Класс это родовое понятие, а объект это видовое понятие.
Экземпляр класса это тоже самое что объект.
Класс это коробочка для упаковывания функций и переменных.
Класс - объединение кода и данных (инкапсуляция).

Модуль тоже объединение кода и данных, в чем отличие от класса?
Мы не можем создавать экземпляры модуля. Но у модулей и классой общая цель декомпозиции программного кода.
Модуль может содержать и фунции и классы.

"""


class Goat:  # создать класс абстрактной козы, название с большой буквы, чтобы не путать с функцией
    age = 0  # классовый атрибут

    def __init__(self):
        pass

    @staticmethod
    def pet():
        print("hello")


mashka = Goat()  # обращаемся к классу козы как будто вызов функции. Создаем экземпляр класса коза, коза Машка
mashka.age = 5  # экземплярный атрибут
mashka.pet()
