"""
Система контроля версий

До существования системы контроля версий, программисты хранили копии программ на диске в архивах по папочкам.
Для того, чтобы отличать копии программы на разных стадиях разработки ввели понятия версий.
.....
Programm_v.1.2.3.zip
Programm_v.1.2.4.zip
(Например программа такой версии, где 1 - означает мажорную версию, 2 - минорную версию, а 4 - микроверсию)
Важно понимать в чем конкретно разница в программном коде между версиями программы.
Была такая программка diff, которая могла показать разницу между программами.
Но при этом не отражалась метаинформация, кто и когда сделал эти изменения, комментарии и т.д.
И версии программ хранились целиком, а хорошо бы хранить лишь только разницу между версиями.
В первых системах контроля версий все хранилось в центральном репозитории, но было не совсем удобно.
Все лучшие идеи реализованы в современной системе GIT. В систему контроля версий diff тоже входит и теперь.
Когда люди стали активно использовать итеративную обработку, появилась необходимость очень часто делать
коммиты. И не вегда есть доступ в интернет, поэтому существует локальный репозиторий и удаленный репозиторий.
Когда делаем коммит, то он происходит в локальный репозиторий. Можем откатывать на прежние версии.
Удаленный репозиторий служит центром объединения историй разработки всех участников проекта.

git clone "link"  # клонируем существующий проект с удаленного репозитория
git status  # проверка статуса локального репозитория
git log # проверка истории коммитов локального репозитория
git diff  # посмотреть какие изменения произошли с прошлого коммита
git add file.txt  # добавить файл file.txt  в отслеживаемые
git add *  # добавить все файлы в проекте в отслеживаемые
git commit -m "message"  # создание коммита в локальном репозитории с сообщением
git commit  # создание коммита, текст сообщения к которому нужно будет ввести в окне редактора
git pull # подтянуть историю с удаленного репозитория
git push  # отправить историю с локального репозитория в удаленный репозиторий
git stash  # положить свою локальную историю изменений после последнего коммита в "карман"
    затем нужно сделать git pull и подтянуть новые изменения с удаленного репозитория и синхронизироваться
git stash pop  # история изменений из временного "кармана" достается и добавляется поверх последнего коммита
При такой последовательности действий пристыковка будет происходить "бесшовно", т.е. без возникновения
merge коммита. Merge коммит возникает при расхождении истории локального и удаленного репозитория и в итоге
возникает конфликт, который может разрешиться автоматически в процессе merge коммита, но может и потребоваться
ручная корректировка, с указанием какие изменения считать приоритетными. В итоге произойдет слияние (merge).

Событийное программирование

Классический вариант - программу запустили и она должна закончить свои действия как можно скорее и закончить.

Другой вариант:
Программу запустили, она себя инициализировала и уснула.
В системе могут происходить события (движения мышкой, сетевой пакет, нажатие клавиши....) и на некоторые
события может реагировать программа и выходить из состояния сна и что-то делать. Так рождается объект события.
Объект события после создания поступает в очередь событий на обработку. Из этой очереди по принципу FIFO
происходит обработка всех событий и по окончанию программа снова засыпает.
Если программа все время будет бодрствовать, она будет сжигать процессорное время и энергию.
Процесс обработки событий называется диспетчеризацией. В pygame требуется обрабатывать события вручную.
В некоторых программах бывает автоматическая обработка событий.

"""
