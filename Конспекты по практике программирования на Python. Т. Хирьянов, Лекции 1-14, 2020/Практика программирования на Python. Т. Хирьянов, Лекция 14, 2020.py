"""
ОПЕРЕЖАЮЩЕЕ ТЕСТИРОВАНИЕ (test first)

Декомпозиция программы как возможность разделения труда, программу можно разделить на кусочки и писать ее как отдельные
модули. Модульное тестирование позволяет тестировать отдельные компоненты программы по отдельности.
Мы должны некоторым образом присоединить модуль программы к тестирующему модулю, который осуществляет ряд некоторых
действий.
Бывает компоненты которые не подлежат или почти не подлежат тестированию, которые трудно изолировать отдельно
и проверить работу тестирующим модулем.

Разработка через тестирование (test-driven development):
- итеративная методика разработки программ, в которой опережающее тестирование ("test-first") ставится во главу угла.
- тестированию не просто отдается больший приоритет, но оно управляет процессом дизайна программного продукта.

Цикл разработки по системе test-driven development написать функции заглушки и далее:
1) - написать тест
     если тесты пройдены, значит пишем еще тесты, без кода тесты не должны проходить - возвращаемся к п. 1
2) - написать код (сделать реализацию)
3) - запустить все тесты
     если тесты заваливаются, значит необходимо улучшать и доработать программный код, возвращаемся к п. 2
4) - рефакторинг программного кода, потом повторяем цикл разработки, возвращаемся к п. 1.

Вопросы дизайна, возникающие при разработке тестов:
- Каковы обязанности тестируемой системы?
- Что и когда она должна делать?
- Какой API удобен для выполнения задуманной функциональности?
- Что конкретно нужно тестируемой системе для выполнения обязательств?
- Что мы имеем на выходе?
- Какие есть побочные эффекты работы?
- Как узнать, что система работает правильно?
- Достаточно ли хорошо определена эта "правильность"?

Преимущества TDD (разработки через тестирование):
- эффективное совмещение ролей (тестирование собственного кода)
- рефакторинг без риска испортить код
- реже нужно использовать отладчик
- повышает уверенность в качестве программного кода

Модуль Unittest - unit testing framework

https://docs.python.org/3/library/unittest.html
по ссылочке из документации возьмем пример тестирования TestStringMethods

Для тестирования даже обычной функции создается класс,
подразумевается что класс соответствует набору тестовых сценариев,
а само тестирование делится на так называемые тесткейсы,
в которых могут осуществляться несколько тестирующих действий.
В этом классе есть функции, которые начинаются со слов "test_" - это важно, потому что это будет определять
автоматический запуск этих тестов.
Важно понимать, что корректное прохождение тестов это только половина дела, а еще нужно учитывать время и память.
Прохождение теста должно укладываться в лимит времени, и даже может быть мы хотим установить лимит используемой памяти.

Представим, мы тестируем функцию для нахождения чисел Фибоначчи и наша функция работает только с целыми числами.
Тесты можно разделить по сложности на некоторые категории:
- simple (0 -> 0, 1 -> 1, 2 -> 1, 3 -> 2 ...)
- stress (50 -> ?, 100 -> ? ... как-то надо учесть время)
- проверка на устойчивость (будет подавать всякую ерунду и посмотрим как будет реагировать программа)
    - negative (-1 -> ?, -100 -> ?...)  # например отрицательные числа
    - wrong type:
        - float numbers (0.3 -> ?, 1.34566 -> ?)  #  дробные числа
        - strings ('what' -> ?, 'kjsdfg' -> ?)  #  строки

Мы будем ловить факт падения программы, но само падение должно происходить неким "законным" образом, т.е.
должен быть адекватный отказ программы на выполнение неадекватных действий. Для того, чтобы программа могла сделать
"адекватный" отказ выполнять "неадекватные" действия, существует специальный механизм - механизм исключений.
Есть набор стандартных исключений (exceptions), и исключение ValueError подойдет для неадекватных значение
или TypeError при ошибке типа.

Практический пример работы с unittest сохранен в файле:
~Python projects\\Learning_Python\\Встроенные библиотеки\\Unittest\\test_fib_function.py
"""